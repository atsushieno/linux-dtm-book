# 音楽ソフトの入手方法

## パッケージからインストールする

Linuxディストリビューションはパッケージソフトウェアの集合体です。DAWやオーディオプラグインのようなソフトウェアもその一部となり得ます。ポピュラーなDAWは、公式パッケージとしてインストールすることも可能かもしれません（Linuxディストリビューションによります）。もし公式パッケージでインストールできて、かつそのバージョンに（古すぎる等の）不満が無ければ、それが一番楽なセットアップ方法でしょう。

synapticやpacmanのようなパッケージマネージャーがインストールされていれば、その中には"Multimedia"のようなカテゴリーが含まれていて、その中にオーディオ関連のアプリケーションが集められている可能性が高く、その中から面白そうなアプリケーションを探すことも可能です（パッケージマネージャーはLinuxディストリビューションによって異なります）。

![synapticのMultimediaカテゴリー](./images/synaptic.png)

ディストリビューション公式パッケージは、アプリケーションの開発元が公開しているパッケージと比べると古いのが一般的です。DAWやプラグインの開発元がバイナリパッケージをリリースしていれば、それらを使うのが最も満足度が高いでしょう。ただし自分から積極的にパッケージをダウンロードしてインストールしたり、パッケージの提供URLをパッケージマネージャーに追加しないといけなかったりはします。

開発者が公式にパッケージを提供していないディストリビューションであっても（あるいは最初からLinux版をサポートしていなくても）、アプリケーションのパッケージングに長けた外部の開発者が独自にパッケージを作って公開している場合があります。場合によっては開発者が公式にREADMEなどで言及していることもあります。それらが提供されていれば、公式パッケージをインストールするのと同程度には簡単にインストールできます。ただ、開発者が自ら提供しているパッケージと比べると信用度が下がる（悪意ある改変が加えられたパッケージが配布されている可能性がある）ことには注意しましょう。

パッケージのインストール方法としては、ディストリビューション固有のパッケージマネージャーの他に、Flatpakやsnapを使うことも考えられます。注意点として、flatpakのようなアプリケーションのコンテナー環境では、JackのAPIを使ったオーディオアクセスにはPipeWireが必要です。

![flatpakで"music"を検索した結果(抜粋)](./images/flatpak.png)

#### StudioRackプロジェクト

筆者が理想としている音楽制作環境は、どのプラットフォームで制作した音楽データをどこにでも以降できることであり、そのためにLinux環境でも利用できるソフトウェアの充実が課題だと思っていますが、類似の目標意識をもってオープンソースで利用可能なオーディオプラグインを収集し、時にはビルドスクリプトを開発者に提供しつつ、Webサイトにまとめてパッケージを提供しているStudioRackというプロジェクトがあります。オーディオプラグインベンダーWavesが出しているStudio Rackという製品と名前がかぶっているので検索性が悪いのですが、`StudioRack github`などで検索するとこのプロジェクトの情報が出てきます。

インストール方法はやや独特ですが、よく知られたプラグインのインストールを楽にするためのプロジェクトなので、セットアップに苦労したら活用してみるとよいでしょう。

## Windows用のオーディオプラグインを使用する

現実的な問題として、Linux用オーディオプラグインのラインアップは、Windows用のそれには遠く及びません。一方で、Windows用ソフトウェアは、Wineを使うと動かせるものが少なくありません。STEAMでは、Windows版のゲームをWineでそのまま動かせるとしていくつかのパッケージが販売されています。オーディオプラグインの場合は特にVST2/VST3のAPIが実装されていればよく、プラグイン本体にWineでも実装されていないような機能を実装する場面は少なく、特に基本的に.NETなどを使わずC++で作られているはずで、Wineとの相性はだいぶ良いはずです。

オーディオプラグインの実装テクニックのひとつとして、自身をオーディオプラグインとしてそのプラグインフォーマットのAPIを実装しつつ、その中では他のプラグインをホストして呼び出す、いわゆるプラグインラッパーあるいはブリッジと呼ばれる手法があります。オーディオプラグインとして、Wineの機能を使ってWindowsのプラグインをブリッジするソフトウェアが、Linuxデスクトップでは古くから開発されてきました。

これらはWineが成熟する以前からさまざまな開発者によって作られてきたもので、2022年の本書執筆時点ではrobbert-vdh/yabridgeがお薦めです。少し古い情報であれば、Airwave、LinVSTといったツールが紹介されていると思います。MelodyneやSerum、OTTが動作している様子が見られます。筆者はLinuxネイティブプラグインを使うので、yabridgeを使ったことはほとんどありませんが、OTT、Varhalla Supermassive、Plogueなどは動作確認しています。

![yabridgeのスクリーンショット（READMEより）](./images/yabridge.png)

yabridgeの基本的な使い方を少しだけ説明します。うまく行かない場合はGitHubプロジェクトの`README.md`を参照してください。

- Wineを使用して、Windows用のオーディオプラグインをインストールします。インストーラーが無い場合は、一般的には`~/.wine/drive_c/Program Files/Common Files/VST2`（VST2の場合）や `~/.wine/drive_c/Program Files/Common Files/VST3`（VST3の場合）にファイルをコピーします（VST3の場合は`*.vst3`の形式のディレクトリ名になるはずです）。
- yabridgeのバイナリパッケージは公式GitHubリポジトリのReleaseページ、あるいはOpen(SUSE) Build Service (OBS)上にあります。`*.tar.gz`アーカイブの場合は、ダウンロードして内容を `~/.local/share/` ディレクトリ以下に展開します。`~/./local/share/yabridge`というディレクトリができるはずです。このディレクトリの中に`yabridgectl`というツールがあるので、これを次に使います。OBSパッケージの場合は、このツールがPATHの通った場所にインストールされていることでしょう。
- `yabridgectl`を使って、Wine上のVST2/VST3のパスを追加します。例: `~/.local/share/yabridge/yabridgectl add ~/.wine/drive_c/Program Files/Common\ Files/VST3`（VST3の場合）
- yabridgeの`sync`コマンドを実行すると、Linux環境上の`~/.vst`や`~/.vst3`にyabridgeのプラグインが追加されます: `./local/share/yabridge/yabridgectl sync`

これでDAWを開いて、プラグインリストを最新の状態に更新してみると、yabridgeがVSTプラグインとしてリストアップされるでしょう。全てのWine上のプラグインが1つのyabridgeというプラグインコンテナーに含まれた状態として認識されるはずです。

![Bitwig Studioでyabridgeが検出された状態](./images/yabridge-detected.png)

## オープンソースのプラグインをソースコードからビルドする

序文にも書きましたが、本書で紹介するソフトウェアには、バイナリパッケージが用意されていないものがあります。それらを使うためには、読者各位のPC上でソースコードからビルドしてインストールする必要があります。これはプログラマーでない読者にとっては難しく見える作業でしょうが、一般的なプログラマーにとっても（慣れた作業に聞こえるとしても）本書で紹介するソフトは特殊で、一般的な経験は通用しません。「./configure; make; sudo make install でいける」ものは多くありません。逆に、「インストール」する作業も、特にオーディオプラグインの場合は単にホームディレクトリ以下の所定のディレクトリにコピーするだけのことが多く、比較的安全に「システムを壊す」心配なく済ませることができます。

日本ではソフトウェアのビルドはプログラマーの仕事とみなされることが多いと思いますが、筆者の周辺にはたまに「プログラミングはできないがオープンソースのツールをインストールして使うくらいはできる」という職業ソフトウェアユーザーが（日本人でも）少なからずいます。そもそもプログラミングに類する作業もプログラマー以外の従業員が着手していたりします。義務教育でプログラミングが普及すれば、このような傾向はさらに拡大するでしょう。

ソースコードからのビルドとインストールは、「コマンドラインで指定されたコマンド／実行すべきコマンドを必要な時に実行するだけ」であって、プログラミングの知識が無くても何とかなります。出自不明で自分でもよくわからないコマンドの実行（特に得体の知れないサイトに載っているようなもの）には警戒すべきですが、読者にとって筆者が何者であるかが明らかで、いつでも公開の場で糾弾できる本書に、危険なコマンドを掲載するのは筆者にとってはデメリットだらけで、読者が恐れる理由はほぼ無いと思います。とはいえ、筆者が無知／無頓着で危険なスクリプトを提示する可能性は常に警戒したほうが良いでしょう。心配な場合は周囲の詳しい知人などに質問しつつ、不必要に恐れることなく実行することをお勧めします。

## ソースからビルドする場合の手順

オーディオプラグインのソースには特殊なものもありますが、一般的なビルドシステムを使っているものもあります。プロジェクトによってはひとつのビルドスクリプトの中で複数のビルドシステムを部分的に利用していることもあります。一方で複数のビルドシステムをサポートしているだけ（どれを使っても良い）ということもあります。正確なことは、それぞれのプロジェクトのREADMEなどのドキュメントを見てください。

もっとも、オーディオプラグインのソースによっては、READMEが不親切な場合も少なからずあります。典型的なパターンとしては「これはJUCEのプロジェクトなんだからJUCEアプリのビルド方法なんて説明しない」という感じのものです。「WindowsのVisual Studio用のソリューションファイル`*.sln`がリポジトリに入っていれば、それをVisual Studioで開くだけ」「MacのXcode用の`*.xcodeproj`が入っていればXcodeで開くだけ」なのが自明であるのと同様です。とはいえ、これは知識がないと分からない話なので、この節ではJUCEを含む、典型的なビルドスクリプトファイルとビルド方法について、説明しておこうと思います。

### オーディオプラグイン以外でも使われるビルドシステム

次のリストは「一般的なほう」のビルドシステムです。

- **CMake**: ソースツリー（ディレクトリツリー）に`CMakeLists.txt`というファイルがあれば、そのプロジェクトではCMakeというビルドシステムが使われています。この場合、典型的なビルド手順は、（cmakeをシステムにインストールした上で）`cmake -Bbuild -GNinja`からの`cmake --build build`となります。CMakeはソースツリーに影響を及ぼさずにビルドディレクトリ（この手順例の場合は`build`）以下にビルド中間ファイルとビルド結果を全て生成します。`sudo cmake --install build`などもサポートされているかもしれませんが、VST2やVST3の場合は、ビルド結果を`~/.vst`や`~/.vst3`にコピーするだけのほうが安全です。ビルドディレクトリの中から`find build -name *.vst3`などを実行して、コピーすべきファイル／ディレクトリを探してください。CMakeは数多くのプラグインの開発に使われているJUCEの比較的新しいバージョンであるJUCE6以降でもサポートされており、`CMakeLists.txt`があればJUCEのプロジェクトのものである可能性がそこそこ高いです。
- **Make**: ソースツリーに`Makefile`というファイルがあれば、そのプロジェクトは`make`でビルドするものである可能性が高いです。Linuxで特にLV2をサポートするプラグインの場合は、`DISTRHO/DPF`というオーディオプラグインフレームワークが使われていることが少なからずあります。ビルド結果がどこに作られるかはプロジェクト次第ですが（CMakeのように洗練されたビルド出力ディレクトリは存在しないでしょう）、`find . -name *.vst3`などで探せるでしょう。
- **meson**: ソースツリーに`meson.build`というファイルがあれば、そのプロジェクトではMesonという比較的新しいビルドシステムが使われています。この場合の典型的なビルド手順は、ninjaとmesonをシステムにインストールするか、mesonのソースツリーをチェックアウトして、`meson setup build`からの`ninja -C build`を実行することとなるでしょう（mesonソースツリーから実行する場合はトップディレクトリの`meson.py`を`meson`の代わりに実行します）。
- **autotools**: ソースツリーに`configure`や`autogen.sh`といったファイルが含まれていれば、それはGNU Autotoolsをビルドシステムとして使用している可能性が高いです。典型的なビルドは`./configure; make; sudo make install`のようになるでしょうが、Autotoolsの使い方はLinuxの一般的な話になるので、これ以上は割愛します。

### JUCE: Projucer

JUCEはかつてProjucerという独自のビルドシステムのみをサポートしていました。もしソースツリーに`*.jucer`というファイルがあれば、それはProjucer用のプロジェクトファイルです。ProjucerはCMakeやmesonと同様、それ自体はビルドツールではなく、プラットフォームに合わせてVisual StudioのプロジェクトやXcodeのプロジェクト、Linux用にはMakefileを生成したりするものです。JUCEのProjucerはGUIツールでもあり、これでロードすることもできます。

GUIでビルドファイルを生成するというのは、必ずしも作業体験が良いわけではなく、特にビルドの自動化とは相容れません。Projucerは`--resave`という引数を指定すると、コマンドラインだけで`.jucer`から各種プロジェクトファイルをエクスポートできます。

Projucerからビルドファイルをエクスポートすると、Linuxの場合は（デフォルトでは）`Builds/LinuxMakefile`というディレクトリが作られ、その中に`Makefile`が生成されます。`make -C Builds/LinuxMakefile`でこのMakefileに記述されたビルドを実行できます。ビルド結果は`Builds/LinuxMakefile/builds/`以下に作られるので、その中から（VST3の場合は）`*.vst3`などのディレクトリを`~/.vst3`以下にコピーすれば使えるようになります。

Linuxサポートに関しては、Projucerのプロジェクトにはひとつ問題があります。開発者がLinux環境の存在を意識していない場合、LinuxのMakefileをエクスポートする設定が含まれていない可能性があります。その場合、`.jucer`ファイルを編集してLinux用ビルド設定を追加する必要があります。

また、ProjucerはJUCEのバージョンにも密接に結びついているところがあり、生成されたプロジェクトファイルが古いままでJUCE本体をアップデートしたりすると、ビルドに失敗します。JUCEを使用したプラグインはJUCEをgit submoduleで指定していることも多く、そのJUCEのソースツリーに含まれているProjucerを使用してビルドするほうが確実です。

なお、JUCEでLinux環境でのVST3がサポートされるようになったのはJUCE6以降のみなので注意が必要です。もしVST3版を使いたいプラグインでJUCE5.4.7以前のバージョンが使われていたら、まずJUCE6にアップグレードしてみるとよいでしょう。ただしこれはプログラムの修正が必要になるかもしれないので、難しそうなら諦めてWindows版のVST3をyabridgeで使うのも手です。

JUCEプロジェクトによっては、ビルドするユーザーがVST2 SDKをダウンロードして持っていることを前提としていることがよくあります。現在すでに入手不可能になっているので、すでに持っているユーザーでなければビルドが失敗することになります。Projucerを使っているプロジェクトであれば、そのファイルの`buildVST`とある部分を消すか`buildVST3`と書き換えて上記`--resave`コマンドで`Makefile`を生成し直すと、うまく行くことがあります。（この辺りまで来るとかなりプログラマー寄りの知識が必要になってきて、本書のスコープからは外れすぎてしまうので、これ以上のトラブルシューティングは本書の範囲外とします。）

### waf

wafはPythonで作られたビルドシステムのひとつですが、LV2本家がwafを使っていることもあってか、LV2プラグインのビルドによく使われています。近年ではCMakeやmesonなどwaf以外のビルドシステムも使われているようです。

wafが使われている場合は、`waf`というスクリプトファイルが含まれている場合がほとんどで、別途ビルドツールをダウンロードする必要は通常はありません。たまにLV2の作者が作った`autowaf`というwafの補助ライブラリがgitのsubmoduleで参照されていることがあるので、（autowafを使っている）LV2プラグインのソースをgitリポジトリからチェックアウトした場合は、`git submodule update --init recursive`を忘れずに実行しましょう。
